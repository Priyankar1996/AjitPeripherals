// Register Addresses
$parameter BlockSize 4
$parameter BlockCount 6
$parameter Argument 8
$parameter Transfer 12
$parameter Command 14
$parameter Response0 16
$parameter Response2 20
$parameter Response4 24
$parameter Response6 28
$parameter BufferDataPort 32
$parameter PresentState 36
$parameter HostControl 40
$parameter PowerControl 41
$parameter ClockControl 44
$parameter SoftwareReset 47
$parameter NormalInterruptStatus 48
$parameter ErrorInterruptStatus 50
$parameter NormalInterruptStatusEnable 52
$parameter ErrorInterruptStatusEnable 54
$parameter NormalInterruptSignalEnable 56
$parameter ErrorInterruptSignalEnable 58
$parameter AutoCmdError 60
$parameter HostControl2 62
$parameter Capabilities 64

// Register set size

$parameter REGISTERSETSIZE 256
//useful constants
$constant ZERO_8: $uint<8> := 0
$constant ZERO_16: $uint<16> := 0
$constant ZERO_32: $uint<32> := 0
$constant ZERO_1: $uint<1> := 0
$constant ONE_1: $uint<1>:= 1
// Registers are byte addressable
// Therefore an array of size 256 
// Each of 8-bits

$storage sdhcRegisters: $array [REGISTERSETSIZE] $of $uint<8>

//Read-only register (RO): Register bits are read-only and cannot be altered by software or any reset
//operation. Writes to these bits are ignored.
//Read-only status (ROC): These bits are initialized to zero at reset. Writes to these bits are ignored.
//Read-Write register (RW): Register bits are read-write and may be either set or cleared by software
//to the desired state.
//Read-only status, Write-1-to-clear status(RW1C): Register bits indicate status when read, a set bit
//indicating a status event may be cleared by writing a 1. Writing a 0 to RW1C bits has no
//effect.
//Read-Write, automatic clear register (RWAC) :The Host Driver requests a Host Controller operation by
//setting the bit. The Host Controllers shall clear the bit automatically when the operation of
//complete. Writing a 0 to RWAC bits has no effect.
//Hardware Initialized(HWInit): Register bits are initialized by firmware or hardware mechanisms such
//as pin strapping or serial EEPROM. Bits are read-only after initialization, and writes to these
//bits are ignored.
//Reserved. These bits are initialized to zero


//main thread: reads from the peripheral to sdhc request pipe
//sends acknowledgment or data through sdhc to peripheral response pipe
//Decodes the address from read data and writes into the particular register 


//peripheral bridge to sdhc request pipe
$pipe peripheral_bridge_to_sdhc_request :$uint<64> $depth 2

//sdhc to peripheral bridge response pipe
$pipe sdhc_to_peripheral_bridge_response :$uint<32> $depth 2 

// Data buffer inside the host controller for writing into sd card of size 512 bytes
$pipe dataBufferTx :$uint<32> $depth 128
// Data buffer inside the host controller for reading from sd card of size 512 bytes
$pipe dataBufferRx :$uint<32> $depth 128


//Pipe for sending Command 
$pipe commandTx :$uint<48> $depth 1
//Pipe for recieving Command 
$pipe commandRx :$uint<48> $depth 1


//Pipe for sending Data
$pipe dataTx :$uint<8> $depth 512
//Pipe for recieving Data 
$pipe dataRx :$uint<8> $depth 512


$module [sdhc_daemon] $in() $out() $is
{

	//read the request pipe
	//split the data into the following 
	// 63: rwbar
	// 62-59: bytemask
	// 55-32: address
	// 31-00: data
	//decide whether to read or write
	//decode register array index from address
	//On completion of write first write to the register then
	//send back zero as acknowledgment through the response pipe
	//On read from register send back data through response pipe
  	
	$branchblock[loop]{
		
		$merge $entry loopback $endmerge

		//read peripheral bridge request
		request := peripheral_bridge_to_sdhc_request 
		$volatile $split (request 1 4 3 24 8 8 8 8) (rwbar bytemask unused address data3 data2 data1 data0)
		//Split the bytemask
		$volatile $split (bytemask 1 1 1 1) (b3 b2 b1 b0)

		$if(rwbar == 0) $then
			$guard(b3)
				sdhcRegisters[((address & _h0000ff) + 0)] := data3
			$guard(b2)
				sdhcRegisters[((address & _h0000ff) + 1)] := data2
			$guard(b1)
				sdhcRegisters[((address & _h0000ff) + 2)] := data1
			$guard(b0)
				sdhcRegisters[((address & _h0000ff) + 3)] := data0
			//Send back zero as acknowledgment
			sdhc_to_peripheral_bridge_response:= ZERO_32
			//When the most significant byte of the Command Register is written 
			//Command should be sent 
			addresscheck := (((address & _h0000ff) + 3) == _h0f)
			$guard(addresscheck)
				$call command_generator () ()
		$else
			
			readdata3 := ($mux b3 sdhcRegisters[((address & _h0000ff) + 0)] ZERO_8)
			readdata2 := ($mux b2 sdhcRegisters[((address & _h0000ff) + 1)] ZERO_8)
			readdata1 := ($mux b1 sdhcRegisters[((address & _h0000ff) + 2)] ZERO_8)
			readdata0 := ($mux b0 sdhcRegisters[((address & _h0000ff) + 3)] ZERO_8)
			//Send back the read value from the registers
			sdhc_to_peripheral_bridge_response := ($concat readdata3 readdata2 readdata1 readdata0)		
			
		$endif
	



		$place[loopback]
	}
} 
// Generating 48 bit command frame
// Also storing the response from the SD card into the Response registers

$module [command_generator] $in() $out() $is
{
	argumentVal3 := sdhcRegisters[{Argument+3}] 
	argumentVal2 := sdhcRegisters[{Argument+2}] 
	argumentVal1 := sdhcRegisters[{Argument+1}] 
	argumentVal0 := sdhcRegisters[Argument]  
	command40bits := ($concat ZERO_1 ONE_1 ($slice sdhcRegisters[{Command + 1}] 5 0) argumentVal3 argumentVal2 argumentVal1 argumentVal0)
	$call generte_crc_7 (command40bits) (crc7)
	command := ($concat command40bits crc7 ONE_1)
	//Sending the commands to the Command transmission pipe
	commandTx := command
	//Recieving response from the SD card
	response := commandRx
	sdhcRegisters[Response0] := ($slice response 39 32)
	sdhcRegisters[{Response0+1}] := ($slice response 31 24)
	sdhcRegisters[{Response0+2}] := ($slice response 23 16)
	sdhcRegisters[{Response0+3}] := ($slice response 15 8)


}
